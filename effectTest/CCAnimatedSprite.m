//
//  ccAnimatedSprite.m
//
//  Created by Jack Ng on 01/04/2010.
//  Copyright 2010 Jack Ng. All rights reserved.
//

#import "CCAnimatedSprite.h"
#import "CCSpriteFrameCache.h"
#import "CCTextureCache.h"


#define CCANIMATEDSPRITE_CURFRAME_KEY @"CCAnimatedSprite_CurFrame"
#define CCANIMATEDSPRITE_CURDURACTION_KEY @"CCAnimatedSprite_CurDuration"
#define CCANIMATEDSPRITE_CURANIMATIONNAME_KEY @"CCAnimatedSprite_CurAnimationName"
#define CCANIMATEDSPRITE_ISREVERSE_KEY @"CCAnimatedSprite_IsReverse"
#define CCANIMATEDSPRITE_SHOULDLOOP_KEY @"CCAnimatedSprite_ShouldLoop"


@implementation CCAnimationFrame
@synthesize frameName;
@synthesize	time;
@synthesize flipX;
@synthesize flipY;

@end


@implementation CCAnimatedSprite
@synthesize curAnimationName;
@synthesize curFrame;
@synthesize numOfFrame;
@synthesize isReverse;
@synthesize shouldLoop;
@synthesize isAnimationEnded;
@synthesize delegate;

- (id) initWithAnimationFile:(NSString*) aniamtionFileName_{
	self = [super init];
	
	if(self != nil){
		NSString* animationPath = [[NSBundle mainBundle] pathForResource:aniamtionFileName_ ofType:@""];	
		NSDictionary* content = [NSDictionary dictionaryWithContentsOfFile:animationPath];
//		NSDictionary* content =[[FileManager sharedManager] getNSDictionaryForFile:animationPath];
		
		//read the frame data from .plist generated by zwoptex
		NSString* animationFrameDataPath = [content objectForKey:@"FrameDataSource"];
		NSString* animationFrameImagePath = [content objectForKey:@"FrameImageSource"];
		CCTexture2D *texture = [[CCTextureCache sharedTextureCache] addImage:animationFrameImagePath];
		
		animationFrameDataPath = [[NSBundle mainBundle] pathForResource:animationFrameDataPath ofType:@""];
		NSDictionary* animationFrameContent = [NSDictionary dictionaryWithContentsOfFile:animationFrameDataPath];
//		NSDictionary* animationFrameContent =[[FileManager sharedManager] getNSDictionaryForFile:animationFrameDataPath];
		[[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithDictionary:animationFrameContent texture:texture];
		
		
		animationsFrameDict = [NSMutableDictionary new];
		
		//load animation frame
		NSDictionary* animations = [content objectForKey:@"Animations"];
		
		//convert the animations frame data to CCAnimationFrame and store it
		for(NSString* key in [animations keyEnumerator]){
			NSArray* frameArray = [animations objectForKey:key];
			NSMutableArray* newFrameArray = [[NSMutableArray new] autorelease];
			
			for(int i = 0 ;i < [frameArray count];i++){
				NSDictionary* frameData = [frameArray objectAtIndex:i];
				CCAnimationFrame* tempFrame = [[CCAnimationFrame new] autorelease];
				tempFrame.frameName = [frameData objectForKey:@"FrameName"];
				tempFrame.time = [(NSNumber*)[frameData objectForKey:@"Time"] floatValue];
				tempFrame.flipX = [(NSNumber*)[frameData objectForKey:@"FlipX"] boolValue];
				tempFrame.flipY = [(NSNumber*)[frameData objectForKey:@"FlipY"] boolValue];
				[newFrameArray addObject:tempFrame];
			}
			
			[animationsFrameDict setValue:newFrameArray forKey:key];
		}
		
		curAnimationFrameList = nil;
		curAnimationName = nil;
		curFrame = 0;
		numOfFrame = 0;

	}
	
	return self;
}


- (void) tick:(ccTime) timeStep_{
	if(isAnimationEnded && !shouldLoop){
		return;
	}
	
	if(curAnimationFrameList != nil){
		if(curDuration>=frameDuration){
	
			//end of animation in reverse mode
			int nextFrame;
			bool tempIsAnimationEnded = false;
			if(isReverse && curFrame == 0){
				nextFrame = numOfFrame - 1;
				tempIsAnimationEnded = true;
			}
			//end of animation in forward mode
			else if(!isReverse && curFrame == numOfFrame - 1){
				nextFrame = 0;				
				tempIsAnimationEnded = true;
			}
			else{
				nextFrame = curFrame + (isReverse?-1:1);
			}
			
			//if animation ended
			if(tempIsAnimationEnded){
				//if the animation need looping
				//set isAnimationEnded back to false
				if(!shouldLoop){
					isAnimationEnded = tempIsAnimationEnded;
				}
				
				if(delegate != nil){
					[delegate didAnimationEnded:curAnimationName sender:self];	
				}
			}
			
			if(!isAnimationEnded){
				[self setCurAnimationFrame:nextFrame];
			}
		}
		else{
			curDuration += timeStep_;
		}
	}
}

- (void) playAnimation:(NSString*) animationName_{
	[self playAnimation:animationName_ shouldReverse:false];
}

- (void) playAnimation:(NSString*) animationName_ shouldReverse:(bool) shouldReverse_{
	
	self.curAnimationName = animationName_;
	curAnimationFrameList = [animationsFrameDict objectForKey:curAnimationName];
	
	NSAssert(curAnimationFrameList!=nil,@"Aniamtion not exist");
	
	numOfFrame = [curAnimationFrameList count];
	isReverse = shouldReverse_;
	int nextFrame;
	if(isReverse){
		nextFrame = numOfFrame - 1;
	}
	else{
		nextFrame = 0;
	}
	
	isAnimationEnded = false;
	[self setCurAnimationFrame:nextFrame];
}


- (void) setCurAnimationFrame:(int) curFrame_{
	curFrame = curFrame_;	
	curDuration = 0;
	
	CCAnimationFrame* tempAnimationFrame = [curAnimationFrameList objectAtIndex:curFrame];
	frameDuration = tempAnimationFrame.time;
	
	CCSpriteFrame* spriteFrame = [[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:tempAnimationFrame.frameName];
	[self setDisplayFrame:spriteFrame];
	[self setFlipX:tempAnimationFrame.flipX];
	[self setFlipY:tempAnimationFrame.flipY];
	
	if(delegate!=nil){
		[delegate didAnimationFrameChanged:curAnimationName sender:self];
	}
}

- (void) dealloc{
	[animationsFrameDict release];	
	delegate = nil;
	[super dealloc];
	
	
}

#pragma mark NSCoding Protocol Implementation
//##################################	NSCoding Protocol Implementation ###########
- (void)encodeWithCoder:(NSCoder *)aCoder{
	[aCoder encodeInt:curFrame forKey:CCANIMATEDSPRITE_CURFRAME_KEY];
	[aCoder encodeFloat:curDuration forKey:CCANIMATEDSPRITE_CURDURACTION_KEY];
	[aCoder encodeObject:curAnimationName forKey:CCANIMATEDSPRITE_CURANIMATIONNAME_KEY];	
	[aCoder encodeBool:isReverse forKey:CCANIMATEDSPRITE_ISREVERSE_KEY];
	[aCoder encodeBool:shouldLoop forKey:CCANIMATEDSPRITE_SHOULDLOOP_KEY];
}

- (id)initWithCoder:(NSCoder *)aDecoder{
	NSString* tempAnimationName = [aDecoder decodeObjectForKey:CCANIMATEDSPRITE_CURANIMATIONNAME_KEY];
	bool tempIsReverse = [aDecoder decodeBoolForKey:CCANIMATEDSPRITE_ISREVERSE_KEY];
	[self playAnimation:tempAnimationName shouldReverse:tempIsReverse];
	
	shouldLoop = [aDecoder decodeBoolForKey:CCANIMATEDSPRITE_SHOULDLOOP_KEY];
	
	int tempFrame = [aDecoder decodeIntForKey:CCANIMATEDSPRITE_CURFRAME_KEY];
	[self setCurAnimationFrame:tempFrame];
	curDuration = [aDecoder decodeFloatForKey:CCANIMATEDSPRITE_CURDURACTION_KEY];
	
	return self;
}
@end
